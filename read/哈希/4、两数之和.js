// 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
// 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
// 示例:
// 给定 nums = [2, 7, 11, 15], target = 9
// 因为 nums[0] + nums[1] = 2 + 7 = 9
// 所以返回 [0, 1]

// 回顾：
// 242. 有效的字母异位词，这道题目是用数组作为哈希表来解决哈希问题，
// 349. 两个数组的交集，这道题目是通过set作为哈希表来解决哈希问题。
// 再来看一下使用数组和set来做哈希法的局限。
// 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
// set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用

// 所以本题：
// 需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。
// 且本题中，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。
// map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。

// 时间复杂度: O(n)
// 空间复杂度: O(n)
var twoSum = function (nums, target) {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    // 遍历当前元素，并在map中寻找是否有匹配的key
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i; // 如果没找到匹配对，就把访问过的元素和下标加入到map中
  }
  return [];
};
