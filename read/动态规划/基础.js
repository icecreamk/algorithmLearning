// 动态规划，英文：Dynamic Programming，简称DP，
// 如果某一问题有很多重叠子问题，使用动态规划是最有效的。

// 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，


// 我举了一个背包问题的例子。
// 例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
// 动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。
// 但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。
// 所以贪心解决不了动态规划的问题。

// 其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了。
// 而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。
// 大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

// 动态规划的解题步骤
// 做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。
// 状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

// 对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！
//     确定dp数组（dp table）以及下标的含义
//     确定递推公式
//     dp数组如何初始化
//     确定遍历顺序
//     举例推导dp数组

// 一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？
// 因为一些情况是递推公式决定了dp数组要如何初始化！

// 可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。
// 动态规划，dp的学习是黑盒的状态，应该如何debug
// 找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！

// 做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。
//     这道题目我举例推导状态转移公式了么？
//     我打印dp数组的日志了么？
//     打印出来了dp数组和我想的一样么？
