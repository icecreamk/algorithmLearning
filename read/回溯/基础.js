// 回溯是递归的副产品，只要有递归就会有回溯
// 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案

// 回溯法其实就是暴力查找，并不是什么高效的算法。但是为什么要用呢？
// 因为回溯解决的问题都不简单，一般可以解决如下几种问题
// 组合问题：N个数里面按一定规则找出k个数的集合
// 切割问题：一个字符串按一定规则有几种切割方式
// 子集问题：一个N个数的集合里有多少符合条件的子集
// 排列问题：N个数按一定规则全排列，有几种排列方式
// 棋盘问题：N皇后，解数独等等

// 组合是不强调元素顺序的，排列是强调元素顺序。
// {1, 2} 和 {2, 1} 在组合上，就是一个集合
// {1, 2} 和 {2, 1} 在排列上，就是两个集合了。

// 所有回溯法的问题都可以抽象为树形结构！
// 因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。
// for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历

// 总结：
// 求组合问题！、求组合总和！
// 区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。
// 不少录友都是看到可以重复选择，就义无反顾的把startIndex去掉了。
// 本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？
// 我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：回溯算法：求组合问题！、求组合总和！
// 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：电话号码的字母组合

// 注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我在讲解排列的时候会重点介绍。
// 在求和问题中，排序之后加剪枝是常见的套路

// 求组合总和（三）本题集合元素会有重复，但要求解集不能包含重复的组合。
// 所以难就难在去重问题上了。这个去重问题，为了讲解这个去重问题，我自创了两个词汇，“树枝去重”和“树层去重”。

// 在回溯算法：分割回文串
// 本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1。
// 复原IP照分割回文串就多了一些限制，例如只能分四段，而且还是更改字符串，插入逗点。
// if (s.size() > 12) return result; // 剪枝

// 求子集问题！在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。
// 认清这个本质之后，今天的题目就是一道模板题了。
