// 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

// 贪心算法一般分为如下四步：
// 将问题分解为若干个子问题
// 找出适合的贪心策略
// 求解每一个子问题的最优解
// 将局部最优解堆叠成全局最优解



// 但在贪心系列，我发的题目难度会整体呈现一个阶梯状上升，细心的录友们应该有所体会。
// 在刚刚讲过的回溯系列中，大家可以发现我是严格按照框架难度顺序循序渐进讲解的，和贪心又不一样，因为回溯法如果题目顺序没选好，刷题效果会非常差！
// 同样回溯系列也不允许简单困难交替着来，因为前后题目都是有因果关系的，相信跟着刷过回溯系列的录友们都会明白我的良苦用心。


// 总结
// 贪心无套路，也没有框架之类的，需要多看多练培养感觉才能想到贪心的思路。
// 在做贪心题的过程中，如果再来一个数据证明，其实没有必要，手动模拟一下，如果找不出反例，就试试贪心。面试中，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了

// 贪心简单题
// 分发饼干
// K次取反后最大化的数组和
// 柠檬水找零

// 贪心中等题
//     摆动序列
// 单调递增的数字
// 贪心解决股票问题
// 大家都知道股票系列问题是动规的专长，其实用贪心也可以解决，而且还不止就这两道题目，但这两道比较典型，我就拿来单独说一说
//     贪心算法：买卖股票的最佳时机II
// 贪心算法：买卖股票的最佳时机含手续费 本题使用贪心算法比较绕，建议后面学习动态规划章节的时候，理解动规就好
// 两个维度权衡问题
// 在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。
//     贪心算法：分发糖果
// 贪心算法：根据身高重建队列
// 在讲解本题的过程中，还强调了编程语言的重要性，模拟插队的时候，使用C++中的list（链表）替代了vector(动态数组)，效率会高很多。
// 所以在根据身高重建队列（续集）为什么用list（链表）更快！

// 贪心难题
// 贪心解决区间问题
// 跳跃游戏
// 跳跃游戏II
// 用最少数量的箭引爆气球
// 无重叠区间
// 划分字母区间
// 合并区间
// 其他难题
// 贪心算法：最大子序 其实是动态规划的题目，但贪心性能更优，很多同学也是第一次发现贪心能比动规更优的题目。
// 贪心算法：加油站 可能以为是一道模拟题，但就算模拟其实也不简单，需要把while用的很娴熟。但其实是可以使用贪心给时间复杂度降低一个数量级。
// 最后贪心系列压轴题目贪心算法：我要监控二叉树！不仅贪心的思路不好想，而且需要对二叉树的操作特别娴熟，这就是典型的交叉类难题了。