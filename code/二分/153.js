// 寻找旋转排序数组中的最小值

// 153. 寻找旋转排序数组中的最小值
// 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
// 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
// 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
// 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

// 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
// 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

// 示例 1：

// 输入：nums = [3,4,5,1,2]
// 输出：1
// 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
// 示例 2：

// 输入：nums = [4,5,6,7,0,1,2]
// 输出：0
// 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
// 示例 3：

// 输入：nums = [11,13,15,17]
// 输出：11
// 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

// 设 x=nums[mid] 是现在二分取到的数。
// 我们需要判断 x 和数组最小值的位置关系，谁在左边，谁在右边？
// 把 x 与最后一个数 nums[n−1] 比大小：

// 如果 x>nums[n−1]，那么可以推出以下结论：
// nums 一定被分成左右两个递增段；
// 第一段的所有元素均大于第二段的所有元素；
// x 在第一段。
// 最小值在第二段。
// 所以 x 一定在最小值的左边。
// 如果 x≤nums[n−1]，那么 x 一定在第二段。（或者 nums 就是递增数组，此时只有一段。）
// x 要么是最小值，要么在最小值右边。
// 所以，只需要比较 x 和 nums[n−1] 的大小关系，就间接地知道了 x 和数组最小值的位置关系，从而不断地缩小数组最小值所在位置的范围，二分找到数组最小值。

// [4,5,6,7,0,1,2]
var findMin = function (nums) {
  let l = 0,
    r = nums.length - 1;
  const last = nums[nums.length - 1];
  while (l <= r) {
    const mid = Math.floor((l + r) / 2);
    if (nums[mid] > last) {
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  return nums[l];
};

console.log(findMin([4,5,6,7,0,1,2]))
console.log(findMin([11,13,15,17]))
console.log(findMin([3,4,5,1,2]))


// var findMin = function (nums) {
//   let low = 0;
//   let high = nums.length - 1;
//   while (low < high) {
//     const pivot = low + Math.floor((high - low) / 2);
//     if (nums[pivot] < nums[high]) {
//       high = pivot;
//     } else {
//       low = pivot + 1;
//     }
//   }
//   return nums[low];
// };
